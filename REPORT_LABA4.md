#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Петрин С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Язык логического программирования пролог идеально подходит для обработки естественного языка , если мы знаем структуру предложений . Так как с помощью этого мы можем написать алгоритм парсинга предложений . Задача грамматического разбора и анализа естественных и искусственных языков является одной из самых распространенных задач, решаемых языками логического программирования. Это связано с простотой и естественностью реализации процесса переборов с возвратами, а также с удобством манипулирования символьной информацией. На прологе , думаю , можно легко написать генератор каких-то документов или написать текстовый редактор .

## Задание

Реализовать разбор фраз языка (вопросов), выделяя в них неизвестный объекты.

 Запрос: 

?- an_q(["Кто", "любит", "шоколад"], X).

?- an_q(["Где", "лежат", "деньги"], X).

?- an_q(["Что", "любит", "Даша"], X).

Результат: 

X='любить'(agent(Y),object('шоколад')),

Х='лежать'(object('деньги'),loc(Y)),

Х='любить'(agent('Даша'),object(Y)),
 
## Принцип решения

Напишем предикат, который поможет нам разделить наше предложение на части.

```prolog
getElem([],_,_).
getElem([H|T],T,H).
```

Реализуем предикат проверок для 1 и 2 значений.

```prolog
there_agent(Q,S):- Q == 'Кто'; name(S).
there_agent1(Q):- Q == 'Кто'.

there_object1(Q,S):- Q == 'Что'; object(S).
there_object1(Q):- Q == 'Что'.

there_loc(Q,S):- Q == 'Где', loc(S).
there_loc1(Q):- Q == 'Где'.
there_loc2(S):-loc(S).
```


Дальше идёт наш самый главный предикат an_q. Как он работает? Очень просто. Сначала мы всегда пишем наш глагол, который стоит в середине предложения и добавляем к нему мягкий знак. И дальше мы смотрим, что у нас спрашивают: чтобы это узнать, нам поможет такой оператор  как "->" - его смысл "Если не это, значит то". И мы спрашиваем: наш вопрос начинается на "Кто"? Нет. Значит выбираем второй путь. И так далее пока предложение не обработается.

```prolog
an_q(S):- getElem(S,S1,Quastion), getElem(S1,S2,Do),getElem(S2,S3,Something),
      write(Do), write("ь"),
                 (there_agent(Quastion,Something) ->
                 write("(agent("), (there_agent1(Quastion)-> write("Y),");write(Something),write("),")),
                  ( there_loc(Quastion,Something) ->
                 write("loc("),(there_loc1(Quastion)-> write("Y))");write(Something),write("))"));
                  write("object("),(there_object1(Quastion)-> write("Y))");write(Something),write("))")));
                 write("(object("),(there_object1(Quastion)-> write("Y),");write(Something),write("),")),
                 ( write("loc("),(there_loc1(Quastion)-> write("Y))");write(Something),write("))")))).
```

## Выводы

Пролог очень удобен для обработки сообщений и парсинга, это первый язык, на котором я научился это делать. Я могу разделять предложения на части, и работать с отдельными словами если это мне будет нужно. Слышал, что есть такие работы, где занимаются парсингом кода, так вот, на прологе, мне кажется, делать это гораздо легче, потому что работаешь с предложениями напрямую и не возникает никаких глупых ошибок, в отличие от других языков.

