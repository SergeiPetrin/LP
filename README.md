# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Петрин С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки – основная структура данных, применяемая в этом языке. Списки являются основой для организации всех сложных вычислений. Одно из основных свойств списка – отсутствие ограничений на элементы и размер списка. Вложенность списков также ничем не ограничивается. Список в языке трактуется как структура из двух элементов – «головы» и «хвоста». Это разделение является основой вычислений над списками, поэтому наиболее часто применяемый паттерн списка имеет вид [H|T].
Первый элемент списка может иметь любую структуру, а второй – также является списком. Пустой список не содержит элементов и обозначается как [ ].
Вторая базовая структурная единица языка – предикат имеет вид — p(A1,A2,..). Предикаты удобны для группирования данных в одну смысловую единицу. В отличие от списка, количество аргументов предиката фиксировано. Имя предиката пишется с малой буквы, как и все константы в языке.
Переменные всегда начинаются с заглавной буквы. На основе переменных можно строить паттерны для списков. 

Связный список — структура данных, состоящая из узлов. Узел содержит данные и ссылку (указатель, связку) на один или два соседних узла. Списки языка Prolog являются односвязными, т.е. каждый узел содержит лишь одну ссылку.

В языке Prolog программист не сталкивается с явной работой с указателями в узлах, однако ему нужно иметь общее представление о списках, т.к. являясь основной структурой данных в функциональных и логических языках, они обладают рядом существенных отличий от массивов, используемых в императивных языках (таких как С++, Java, Pascal). В частности, элемент данных может быть очень быстро добавлен или удален из начала односвязного списка. Однако операция произвольного доступа (обращения к n-ному элементу) в списках выполняется гораздо дольше чем в массивах, т.к. требует n операций перехода по ссылкам.

## Задание 1.1: Предикат обработки списка

`count(X,Y,Z)` - предикат делает подсчет числа вхождений заданного элемента в список.

Примеры использования:
```prolog
?- count([a,b,c],d,X).
X = 0.
?- count([a,b,c,a],a,X).
X = 2.
```

Реализация:
```prolog
count([], _Element, 0) :- !
count([Element|Tail], Element, Count):-
    !, count(Tail, Element, CountTail),
    Count is CountTail + 1.
count([_Element|Tail], Element, Count):-
    count(Tail, Element, Count).
```

Для пустого списка, любой элемент равен 0, так как в списке ничего не находится.
Если элемент находится в списке, то запускается рекурсия, и мы считаем по 1 элементу, если встречаем наш элемент.

## Задание 1.2: Предикат обработки числового списка

`max(X,Y)` - предикат делает вычисление максимального элемента числового списка.

Примеры использования:
```prolog
?- max([1,3,2,4],X).
X = 4.
?- max([1,3,X,5],6).
X = 6.
```

Реализация:
```prolog
max([N],N)   :- !.
max([H|T],H) :-
    max(T,N1),
    N1<H.
max([H|T],N1) :-
    max(T,N1),
    N1>=H.
```

Если в списке один элемент, то он максимален.
Если в списке больше элементов, запускается рекурсия, которая ищет максимальный элемент.

## Задание 2: Реляционное представление данных

Метод резолюции легко поддается алгоритмизации. Недостатком этого метода является необходимость представления формул в КНФ. Автоматическое доказательство теорем методом резолюций основан на переборе и этот перебор может быть настолько большим, что затраты времени на него практически неосуществимы.

После записи утверждений в базу данных вычисления могут быть инициированы вводом запроса.

Запрос выглядит так же, как и целевое утверждение, образуется и обрабатывается по тем же правилам, но он не входит в базу данных (программу). В Прологе вычислительная часть программы и данные имеют одинаковый синтаксис. Программа обладает как декларативной, так и процедурной семантикой.

Запрос иногда называют управляющей командой (директивой), так как он требует от Пролог-системы выполнения некоторых действий. Во многих реализациях Пролога для управляющей команды используется альтернативный символ, а символ ?- обозначает приглашение верхнего уровня интерпретатора Пролога. Альтернативным символом является :-. Таким образом,
```prolog
:-write(co6aкa).
```
- это управляющая команда, в результате выполнения которой печатается атом собака.
## Выводы

Prolog — уникален. Это единственный язык представляющий парадигму декларативного программирования; это язык, который имеет сотни различных имплементаций, но они все равно называются Prolog, добавляя лишь префиксы и суффиксы к названию; это живой язык в котором не происходит никаких существенных изменений более 20 лет; это, наверное, единственный настолько популярный язык программирования, который не имеет применения в реальном программировании. 

Prolog можно легко читать, но очень тяжело писать, что принципиально отличается от всех mainstream языков, которые так и говорят писать стало еще легче, от этого все мы знаем очень сильно страдает само качество кода. Вроде бы каждая строчка понятна, но как система работает за гранью понимания даже для разработчиков. 

Делая первую лаборатурную работу я разобрался, как Prolog понимает предикаты и доказывает утверждения, понял что, Пролог — это золотая середина, между простым интерпретатором и машиной для доказательства теорем, сдвиг в любую сторон приводит к потери одного из свойств. Когда я с ним работал, я понял, что с ним очень удобно решать логические задачи, что сделает мне жизнь намного проще.
