# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Петрин С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parents(потомок, отец, мать).
 3. Реализовать предикат проверки/поиска двоюродного брата.
 

## Получение родословного дерева

Создал родословное дерево на сайте www.myheritage.com в формате GEDCOM, в этом дерево получилось 20 индивидуумов. 

## Конвертация родословного дерева

Для парсинга я решил использовать язык Python, он мне больше симпатизирует, так как на нём мне легче работать и понимать программу. На вход я получал файл в формате .ged и считывал его построчно. Когда я видел символ "I" я запоминал ключ к имени и фамилии. Когда я видел "GIVN" и "SURN", то я создавал имя и фамилию вместе как значение и записывал под ключ в базу данных. А когда я видел "HUSB", "WIFE", "CHILD", то уже я объединял их и делал из этого предикат parents(CHILD, HUSB, WIFE) и подавал его на выход в файл. Также и с предикатом Sex.

## Предикат поиска родственника

Пройдёмся по программе:

```prolog
solve(X,S):- parents(X,F,M),parents(F,FF,FM), parents(M,MF,MM),
    findall(T, parents(T,FF,FM),FX), length(FX,FN), FN > 1, del(F,FX,FX1), my_pred(FX1,KS),
    findall(T, parents(T,MF,MM),MX), length(MX,MN), MN > 1, del(M,MX,MX1), my_pred(MX1,LS),
    append(KS,LS,S), write(S), nl.

solve(X,S):- parents(X,F,_), parents(F,FF,FM),
    findall(T, parents(T,FF,FM),FX), length(FX,FN), FN > 1, del(F,FX,FX1), my_pred(FX1,S), write(S), nl.

solve(X,S):-parents(X,_,M),parents(M,MF,MM),
    findall(T, parents(T,MF,MM),MX), length(MX,MN), MN > 1,del(M,MX,MX1), my_pred(MX1,S), write(S), nl.
```

Предикат solve ищет/проверяет двоюродного брата. Как он работает? Очень просто. Допустим X - это вы. Сначала он находит ваших родителей, потом родителей ваших родителей - дедушек и бабушек, тоесть их 4, родители мамы и родители папы. Дальше с помощью предиката findall мы находим детей ваших дедушек и бабушек, проверяем, что такие существуют (иначе выдаём false.), удаляем вашего отца, мать из этого списка (иначе вы будете двоюродным братом самому себе), и находим детей ваших дядь и тёть с помощью предиката my_pred.

```prolog
my_pred([],[]).
my_pred([H|T],KS1):-my_pred(T,U),findall(K1,(parents(K1,H,_)->sex(K1,Sex) -> Sex == 'm'),KS1),
                                    findall(K2,(parents(K2,_,H)->sex(K2,Sex) -> Sex == 'm'),KS2),
                                                                             append(KS1,KS2,KS), append(KS,U,KS1).
```
С помощью рекурсии находим детей дядь и тёть. Важно заметить, что мы находим детей мужского пола, потому что мы ищем двоюродных братьев, а не сестёр. 

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.
