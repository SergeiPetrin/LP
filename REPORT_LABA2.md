#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Петрин С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует 2 основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. Они оба перебирают некоторый набор решений. Суть первого метода состоит в том, что некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат и рассмотрение следующего решения, в случае успеха полученное решение возвращается пользователю или используется дальше. Второй метод можно противопоставить первому. В методе ветвей и границ значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Например, можно использовать предикат member одновременно для генерации и для проверки, таким образом генерируются не все варианты решений, а какое-то их подмножество. Очевидно, что программа, написанная с помощью второго метода, будет работать быстрее.

Пролог удобен для решения логических задач, потому что он дает возможность рассмотрения большого количества вариантов решения задачи и выбора из них подходящих. Механизм бэктрекинга при обнаружении неуспеха автоматически пересматривает решение и вытается продолжить выполнение программы при других значениях переменных.

## Задание

Задание №18. В нашем городе обувной магазин закрывается каждый понедельник, хозяйственный каждый вторник, продовольственный каждый четверг, а парфюмерный магазин работает только по понедельникам, средам и пятницам. В воскресенье все магазины закрыты. Однажды подруги Ася, Ира, Клава и Женя отправились за покупками, причем каждая в свой магазин и притом в один. По дороге они обменивались такими замечаниями. Ася. Женя и я хотели пойти вместе еще раньше на этой неделе, но не было такого дня, чтобы мы обе могли сделать наши покупки. Ира. Я не хотела идти сегодня, но завтра я уже не смогу купить то, что мне нужно. Клава. А я могла бы пойти в магазин и вчера и позавчера. Женя. А я могла бы пойти и вчера и завтра. Скажите, кому какой магазин нужен?

## Принцип решения

Для начала реализуем наши предикаты из задачи: по каким дням работают магазины, а по каким дням они закрыты - shop_open и close1 соотвественно. 

```prolog
shop_open('obuv','vtornik').
shop_open('obuv','sreda').
shop_open('obuv','chetverg').
shop_open('obuv','pyatnica').
shop_open('obuv','subbota').

shop_open('hoz','ponedelnik').
shop_open('hoz','sreda').
shop_open('hoz','chetverg').
shop_open('hoz','pyatnica').
shop_open('hoz','subbota').

shop_open('prod','ponedelnik').
shop_open('prod','vtornik').
shop_open('prod','sreda').
shop_open('prod','pyatnica').
shop_open('prod','subbota').

shop_open('parfum', 'ponedelnik').
shop_open('parfum', 'sreda').
shop_open('parfum', 'pyatnica').

close1('parfum', 'vtornik').
close1('parfum', 'chetverg').
close1('parfum', 'subbota').
close1('obuv','ponedelnik').
close1('hoz','vtornik').
close1('prod','chetverg').
```

Реализуем предикаты, которые нам пригодятся при решении задачи:

1. Получении длины списка.
```prolog
getLenList([],0).
getLenList([_|L],N):- getLenList(L,N1), N is N1+1.
```
2. Нахождение максимального элемента в списке.
```prolog
findmax([L|Ls], Max) :-
    findmax(Ls, L, Max).

findmax([], Max, Max).
findmax([L|Ls], Max0, Max) :-
    Max1 is max(L, Max0),
    findmax(Ls, Max1, Max).
```
3. Получение индекса максимального элемента.
```prolog
num([],N,_):- N is 0.
num([L|_],N,Max) :- N is 1, L = Max.
num([_|Ls],N,Max):- num(Ls,N1,Max), N is N1+1.
```
4. С помощью этого предиката я буду обозначать какой день был вчера, позавчера, какой день сегодня и какой день будет завтра.
```prolog
day([],_,_,_):-!.
day([L|_],N,L,Num):- N=Num.
day([_|Ls],N,S,Num):- Num1 is Num + 1, day(Ls,N,S,Num1).
```
5. С помощью этого предиката я нахожу магазин, который открыт в определенные дни.
```prolog
poisk(NextDay,PrevDay, S, Name,_,_,_,_,_,_, Name):- member(NextDay,S), member(PrevDay,S).
poisk(NextDay,PrevDay, _, _,S,Name,_,_,_,_, Name):- member(NextDay,S), member(PrevDay,S).
poisk(NextDay,PrevDay, _, _,_,_,S,Name,_,_, Name):- member(NextDay,S), member(PrevDay,S).
poisk(NextDay,PrevDay, _, _,_,_,_,_,S,Name, Name):- member(NextDay,S), member(PrevDay,S).
poisk(\_,_, _, _,_,_,_,_,_,_, 'No'):-!.
```

Наконец, мы дошли к главному предикату - work. Давай-те разберем его по частям.

1. Нам надо понять, какой сегодня день, какой день был вчера и позавчера, и какой день будет завтра. Сначала мы сделаем список дней по порядку начиная с понедельника. Дальше узнаем сколько магазинов было открыто на каждом дне. Находим день, в котором все магазины были открыты. Сегодня среда, значит вчера был вторник, позавчера был понедельник, а завтра будет четверг.
```prolog
 L = ['ponedelnik','vtornik','sreda','chetverg', 'pyatnica', 'subbota', 'voskresenye'],
     F = [F0,F1,F2,F3,F4,F5,F6],
     findall(X,shop_open(X,'ponedelnik') ,Pn),
     findall(X,shop_open(X,'vtornik') ,Vt),
     findall(X,shop_open(X, 'sreda') ,Sr),
     findall(X,shop_open(X,'chetverg') ,Ch),
     findall(X,shop_open(X,'pyatnica') ,Pt),
     findall(X,shop_open(X,'subbota') ,Sb),
     findall(X,shop_open(X,'voskresenye') ,Vs),
     getLenList(Pn,F0),
     getLenList(Vt,F1),
     getLenList(Sr,F2),
     getLenList(Ch,F3),
     getLenList(Pt,F4),
     getLenList(Sb,F5),
     getLenList(Vs,F6),

     findmax(F,Max),
     num(F,N,Max),
     day(L,N,NowDay,1),
     N1 is N + 1, N2 is N - 1, N3 is N2 - 1,
     day(L,N1,NextDay,1),
     day(L,N2,PrevDay,1),
     day(L,N3,PrevprevDay,1),
```
2. Дальше мы делаем списки расписания магазинов, мы знаем, что Женя могла пойти вчера и может пойти завтра, значит мы ищем такой магазин - узнаем, что этот магазин обуви. Также мы знаем и про Клаву, то что она могла пойти вчера и позавчера, перебираем все варианты и получаем, что ей нужно в продовольственный магазин.
```prolog
     findall(X,shop_open('obuv',X) ,Ob),
     findall(X,shop_open('hoz',X) ,Hz),
     findall(X,shop_open('prod', X) ,Prd),
     findall(X,shop_open('parfum',X) ,Prf),

     poisk(NextDay,PrevDay, Ob,'obuv',Hz,'hoz',Prd,'prod', Prf, 'parfum', Zhenya),
     poisk(PrevprevDay,PrevDay, Ob,'obuv',Hz,'hoz',Prd,'prod', Prf, 'parfum', Klava),
```
3. Мы знаем, что Ира не может пойти завтра, так как её магазин будет закрыт. И мы знаем, что это не провольственный и обувной магазины. Находим магазин, который завтра закрыт, исключая Женю и Клаву, понимаем, что это парфюмерный магазин. Ну и исключая всех, находим магазин для Аси - это хозяйственный магазин.
```prolog
findall(X,close1(X,NextDay) ,List1),
     delete(List1,Zhenya,List2),
     delete(List2, Klava, List),
     elem(List,Ira),
     findall(X,shop_open(X,NowDay) ,Result1),
     delete(Result1,Zhenya,Result2),
     delete(Result2, Klava, Result3),
     delete(Result3,Ira,Result),
     elem(Result,Asya),
     write('Ася : '), write(Asya), nl,
     write('Женя : '), write(Zhenya), nl,
     write('Клава : '), write(Klava), nl,
     write('Ира : '), write(Ira), nl,
     !.
```


## Выводы

Пролог, безусловно, удобен для решения подобных задач. Описав ряд условий, мы отсекаем неподходящие варианты и находим нужное решение. Это намного проще, чем решать вручную, если бы мы, подобно программе, проверяли все возможные решения. Насколько эффективнее написание программы по сравнению с "ручным" решением вопрос спорный. Если такая задача одна и там немного входных данных, то проще решить ее на бумаге. На больших данных я все-таки предпочту бы написать программу. Сложно представить себе ситуацию, при которой пришлось бы решать большое количество таких задач. Также стоит отметить, что похожие по смыслу задачи решаются на Прологе механически -- мы просто меняем предикаты с условиями и генерацию. Думаю, если бы мы формализовали условие и написали все возможные проверки вообще (написание которых наверняка тоже можно как-то автоматизировать), то смогли бы решать целые классы таких задач.


